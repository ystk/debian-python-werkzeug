From: pgjones <philip.graham.jones@googlemail.com>
Date: Mon, 24 Jul 2023 15:07:07 +0000
Subject: CVE-2023-25577

Origin: https://github.com/pallets/werkzeug/commit/517cac5a804e8c4dc4ed038bb20dacd038e7a9f1
Reviewed-by: Sylvain Beucler <beuc@debian.org>
Last-Update: 2023-02-25

From fe899d0cdf767a7289a8bf746b7f72c2907a1b4b Mon Sep 17 00:00:00 2001
From: pgjones <philip.graham.jones@googlemail.com>
Date: Sun, 29 Jan 2023 15:17:37 +0000
Subject: [PATCH 1/3] limit the maximum number of multipart form parts

Add a limit to the number of multipart form data parts the parser will
attempt to parse. If the limit is exceeded, it raises
`RequestEntityTooLargeError`.

A default of 1000 seems large enough to allow legitimate use cases while
preventing the previous unlimited parsing. This differs from similar
settings that are unset by default, as I think safe defaults are better
practice.

The limit can be adjusted per request by changing it on the request
object before parsing. For example, it can be set based on what you
expect a given endpoint to handle.

```python
req.max_form_parts = 20
form = req.form
```
---
 werkzeug/formparser.py           | 20 +++++++++++++++-----
 werkzeug/testsuite/formparser.py | 10 ++++++++++
 werkzeug/wrappers.py             | 10 +++++++++-
 3 files changed, 34 insertions(+), 6 deletions(-)

diff --git a/werkzeug/formparser.py b/werkzeug/formparser.py
index b349c96..ef5b19c 100644
--- a/werkzeug/formparser.py
+++ b/werkzeug/formparser.py
@@ -135,12 +135,14 @@ class FormDataParser(object):
     :param cls: an optional dict class to use.  If this is not specified
                        or `None` the default :class:`MultiDict` is used.
     :param silent: If set to False parsing errors will not be caught.
+    :param max_form_parts: The maximum number of parts to be parsed. If this is
+        exceeded, a :exc:`~exceptions.RequestEntityTooLarge` exception is raised.
     """
 
     def __init__(self, stream_factory=None, charset='utf-8',
                  errors='replace', max_form_memory_size=None,
                  max_content_length=None, cls=None,
-                 silent=True):
+                 silent=True, max_form_parts=None):
         if stream_factory is None:
             stream_factory = default_stream_factory
         self.stream_factory = stream_factory
@@ -148,6 +150,7 @@ class FormDataParser(object):
         self.errors = errors
         self.max_form_memory_size = max_form_memory_size
         self.max_content_length = max_content_length
+        self.max_form_parts = max_form_parts
         if cls is None:
             cls = MultiDict
         self.cls = cls
@@ -201,7 +204,7 @@ class FormDataParser(object):
     def _parse_multipart(self, stream, mimetype, content_length, options):
         parser = MultiPartParser(self.stream_factory, self.charset, self.errors,
                                  max_form_memory_size=self.max_form_memory_size,
-                                 cls=self.cls)
+                                 cls=self.cls, max_form_parts=self.max_form_parts)
         boundary = options.get('boundary')
         if boundary is None:
             raise ValueError('Missing boundary')
@@ -283,11 +286,13 @@ _end = 'end'
 class MultiPartParser(object):
 
     def __init__(self, stream_factory=None, charset='utf-8', errors='replace',
-                 max_form_memory_size=None, cls=None, buffer_size=64 * 1024):
+                 max_form_memory_size=None, cls=None, buffer_size=64 * 1024,
+                 max_form_parts=None):
         self.stream_factory = stream_factory
         self.charset = charset
         self.errors = errors
         self.max_form_memory_size = max_form_memory_size
+        self.max_form_parts = max_form_parts
         if stream_factory is None:
             stream_factory = default_stream_factory
         if cls is None:
@@ -468,11 +473,12 @@ class MultiPartParser(object):
 
             yield _end, None
 
-    def parse_parts(self, file, boundary, content_length):
+    def parse_parts(self, file, boundary, content_length, max_parts=None):
         """Generate ``('file', (name, val))`` and
         ``('form', (name, val))`` parts.
         """
         in_memory = 0
+        _parts_decoded = 0
 
         for ellt, ell in self.parse_lines(file, boundary, content_length):
             if ellt == _begin_file:
@@ -501,6 +507,9 @@ class MultiPartParser(object):
                         self.in_memory_threshold_reached(in_memory)
 
             elif ellt == _end:
+                _parts_decoded += 1
+                if max_parts is not None and _parts_decoded > max_parts:
+                    raise exceptions.RequestEntityTooLarge()
                 if is_file:
                     container.seek(0)
                     yield ('file',
@@ -514,7 +523,8 @@ class MultiPartParser(object):
 
     def parse(self, file, boundary, content_length):
         formstream, filestream = tee(
-            self.parse_parts(file, boundary, content_length), 2)
+            self.parse_parts(file, boundary, content_length,
+                             max_parts=self.max_form_parts), 2)
         form = (p[1] for p in formstream if p[0] == 'form')
         files = (p[1] for p in filestream if p[0] == 'file')
         return self.cls(form), self.cls(files)
diff --git a/werkzeug/testsuite/formparser.py b/werkzeug/testsuite/formparser.py
index 850364f..660745b 100644
--- a/werkzeug/testsuite/formparser.py
+++ b/werkzeug/testsuite/formparser.py
@@ -13,6 +13,7 @@ from __future__ import with_statement
 
 import unittest
 from os.path import join, dirname
+import io
 
 from werkzeug.testsuite import WerkzeugTestCase
 
@@ -101,6 +102,15 @@ class FormParserTestCase(WerkzeugTestCase):
         req.max_form_memory_size = 400
         self.assert_strict_equal(req.form['foo'], u'Hello World')
 
+        req = Request.from_values(
+            input_stream=io.BytesIO(data),
+            content_length=len(data),
+            content_type="multipart/form-data; boundary=foo",
+            method="POST",
+        )
+        req.max_form_parts = 1
+        self.assert_raises(RequestEntityTooLarge, lambda: req.form['foo'])
+
     def test_missing_multipart_boundary(self):
         data = (b'--foo\r\nContent-Disposition: form-field; name=foo\r\n\r\n'
                 b'Hello World\r\n'
diff --git a/werkzeug/wrappers.py b/werkzeug/wrappers.py
index edfb74c..27b7e6b 100644
--- a/werkzeug/wrappers.py
+++ b/werkzeug/wrappers.py
@@ -158,6 +158,13 @@ class BaseRequest(object):
     #: .. versionadded:: 0.5
     max_form_memory_size = None
 
+    #: The maximum number of multipart parts to parse, passed to
+    #: :attr:`form_data_parser_class`. Parsing form data with more than this
+    #: many parts will raise :exc:`~.RequestEntityTooLarge`.
+    #:
+    #: .. versionadded:: 2.2.3
+    max_form_parts = 1000
+
     #: the class to use for `args` and `form`.  The default is an
     #: :class:`~werkzeug.datastructures.ImmutableMultiDict` which supports
     #: multiple values per key.  alternatively it makes sense to use an
@@ -330,7 +337,8 @@ class BaseRequest(object):
                                            self.encoding_errors,
                                            self.max_form_memory_size,
                                            self.max_content_length,
-                                           self.parameter_storage_class)
+                                           self.parameter_storage_class,
+                                           max_form_parts=self.max_form_parts)
 
     def _load_form_data(self):
         """Method used internally to retrieve submitted data.  After calling
